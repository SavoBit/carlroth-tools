#!/usr/bin/python

"""docker-machine-bootstrap

Initial setup of a new docker machine.
"""

import sys
import os
import subprocess
import json
import socket, struct
import argparse
import logging
import tempfile
import shutil

SCP_ROOT = os.path.join(os.path.dirname(__file__), 'docker-machine-scp-root')
NFSOPTS = "rsize=65536,wsize=65536,intr,noatime"

def inet_aton(addr):
    addrBytes = socket.inet_aton(addr)
    addrInt = struct.unpack(">I", addrBytes)[0]
    return addrInt

def inet_ntoa(addrInt):
    addrBytes = struct.pack(">I", addrInt)
    return socket.inet_ntoa(addrBytes)

def inet_bitston(numBits):
    numBits = int(numBits)
    numBits = 32-numBits
    maskInt = (1<<numBits)-1
    maskInt = maskInt ^ 0xffffffff
    return maskInt

def inet_bitstoa(numBits):
    maskInt = inet_bitston(numBits)
    return inet_ntoa(maskInt)

def getShowmount(host):
    cmd = ('showmount', '-e', host,)
    buf = subprocess.check_output(cmd)
    e = {}
    for line in buf.splitlines()[1:]:
        words = line.strip().split()
        v = words.pop(0)
        e[v] = words
    return e

PROFILE_TAIL = """\
# BEGIN profile.tail
#
##############################

DMB_STOREPATH="%(storePath)s"
DMB_VOLUMES="%(volumes)s"
DMB_HOST="%(host)s"
DMB_NFSOPTS="%(nfsopts)s"

if test -f /var/lib/boot2docker/rc.local; then
  . /var/lib/boot2docker/rc.local || :
fi

##############################
#
# END profile.tail
"""

class Bootstrap:

    def __init__(self, machine, srcdir, volumes=[], log=None):
        self.log = log or logging.getLogger(self.__class__.__name__)
        self.machine = machine
        self.srcdir = srcdir
        self.volumes = volumes

        self.data = {}
        self._inspect()

    def _inspect(self):
        cmd = ('docker-machine', 'inspect', self.machine,)
        self.data = json.loads(subprocess.check_output(cmd))

    def setUpProfile(self):

        self.log.info("updating boot2docker profile")
        profilePath = tempfile.mktemp(prefix="profile-")
        cmd = ('docker-machine', 'scp', self.machine + ':' + '/var/lib/boot2docker/profile', profilePath,)
        subprocess.check_call(cmd)
        with open(profilePath) as fd:
            profileBuf = fd.read()

        p = profileBuf.find("\n# BEGIN profile.tail")
        if p > -1:
            q = profileBuf.find("# END profile.tail\n")
            if q > -1:
                profileBuf = (profileBuf[:p+1]
                              + profileBuf[q+19:])
            else:
                profileBuf = profileBuf[:p+1]

        hostAddr, sep, bits = self.data['Driver']['HostOnlyCIDR'].partition('/')

        ctx = dict(storePath=self.data['StorePath'],
                   volumes=" ".join(self.volumes),
                   host=hostAddr,
                   nfsopts=NFSOPTS)
        with open(profilePath, "w") as fd:
            fd.write(profileBuf)
            fd.write(PROFILE_TAIL % ctx)

        cmd = (SCP_ROOT, profilePath, self.machine + ':' + '/var/lib/boot2docker/profile',)
        subprocess.check_call(cmd)
        os.unlink(profilePath)

        self.log.info("installing rc.local")
        rcPath = os.path.join(self.srcdir, "rc.local")
        cmd = (SCP_ROOT, rcPath, self.machine + ':' + '/var/lib/boot2docker/rc.local',)
        subprocess.check_call(cmd)

        return 0

    def setUpExports(self):

        machineAddr = self.data['Driver']['IPAddress']
        self.log.info("machine address %s", machineAddr)

        hostAddr, sep, bits = self.data['Driver']['HostOnlyCIDR'].partition('/')
        self.log.info("host address %s", hostAddr)

        hostAddrInt = inet_aton(hostAddr)
        maskInt = inet_bitston(int(bits))
        mask = inet_ntoa(maskInt)
        netInt = hostAddrInt & maskInt
        net = inet_ntoa(netInt)
        self.log.info("network address %s", net)

        exports = getShowmount(hostAddr)
        self.log.info("found exports for %s", ", ".join(exports))

        needsRestart = False
        for volume in self.volumes:
            needsExport = False
            if volume not in exports:
                self.log.warn("missing export for %s", volume)
                needsExport = True
                needsRestart = True
            elif net not in exports[volume]:
                self.log.warn("missing export for %s --> %s", net, volume)
                needsExport = True
                needsRestart = True
            if needsExport:
                self.log.info("adding export for %s --> %s", net, volume)
                fno, exportPath = tempfile.mkstemp(prefix='exports-')
                with os.fdopen(fno, "w") as fd:
                    with open("/etc/exports") as fd2:
                        fd.write(fd2.read())
                    fd.write("%s -alldirs -maproot=root:wheel -network %s -mask %s\n"
                             % (volume, net, mask,))
                if os.getuid() == 0:
                    shutil.copy(exportPath, "/etc/exports")
                else:
                    cmd = ('sudo', 'cp', exportPath, "/etc/exports",)
                    subprocess.check_call(cmd)
                os.unlink(exportPath)
        if needsRestart:
            self.log.info("restarting nfsd")
            if os.getuid() == 0:
                cmd = ('nfsd', 'restart',)
            else:
                cmd = ('sudo', 'nfsd', 'restart',)
            subprocess.check_call(cmd)

        # test the final result to make sure we are actually exporting
        exports = getShowmount(hostAddr)
        foundAll = True
        for volume in self.volumes:
            if volume not in exports:
                self.log.warn("unable to export %s", volume)
                foundAll = False
            if net not in exports[volume]:
                self.log.warn("unable to export %s --> %s", net, volume)
                foundAll = False
        if not foundAll:
            self.log.error("not all volumes were exported")
            return 1

        return 0

    def run(self):

        if sys.platform != 'darwin':
            self.log.error("hurr, this is meant for MacOS")
            return 1

        # sanitize the volumes,
        # since docker-machine uses the basename as the volume
        vnames = set()
        for v in self.volumes:
            d, b = os.path.split(v)
            if b in vnames:
                self.log.error("ambigous volume name %s", b)
                return 1
            vnames.add(b)

        code = self.setUpProfile()
        if code: return code

        if self.volumes:
            code = self.setUpExports()
            if code: return code

        return 0

    def shutdown(self):
        pass

USAGE = """\
docker-machine-bootstrap [OPTIONS] MACHINE

Export MacOS volumes to docker containers via NFS,
to work around hypervisor guest volume driver bugs.
"""

EPILOG = """\
Useful volume arguments include

  --volume /Users

    to map the default MacOS Users share,
    replacing the hypervisor driver with a proper NFS mount

  --volume /Volumes/data

    for other volumes
"""

ap = argparse.ArgumentParser(usage=USAGE,
                             epilog=EPILOG,
                             formatter_class=argparse.RawDescriptionHelpFormatter)

ap.add_argument("machine", type=str,
                help="Docker machine name")

ap.add_argument("--volume", action='append',
                help="Add an NFS volume (can be specified multiple times)")

def main():
    logging.basicConfig()
    logger = logging.getLogger("dmb")
    logger.setLevel(logging.DEBUG)

    try:
        opts = ap.parse_args()
    except SystemExit, what:
        sys.exit(what.code)

    b = Bootstrap(opts.machine,
                  os.path.dirname(__file__),
                  volumes=opts.volume,
                  log=logger)
    try:
        code = b.run()
    except:
        logger.exception("runner failed")
        code = 1
    b.shutdown()
    sys.exit(code)

if __name__ == "__main__":
    main()
